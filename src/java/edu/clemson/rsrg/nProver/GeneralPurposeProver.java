/*
 * GeneralPurposeProver.java
 * ---------------------------------
 * Copyright (c) 2024
 * RESOLVE Software Research Group
 * School of Computing
 * Clemson University
 * All rights reserved.
 * ---------------------------------
 * This file is subject to the terms and conditions defined in
 * file 'LICENSE.txt', which is part of this source code package.
 */
package edu.clemson.rsrg.nProver;

import edu.clemson.rsrg.absyn.declarations.moduledecl.*;
import edu.clemson.rsrg.absyn.expressions.Exp;
import edu.clemson.rsrg.absyn.expressions.mathexpr.AbstractFunctionExp;
import edu.clemson.rsrg.init.CompileEnvironment;
import edu.clemson.rsrg.init.flag.Flag;
import edu.clemson.rsrg.init.flag.FlagDependencies;
import edu.clemson.rsrg.init.output.OutputListener;
import edu.clemson.rsrg.nProver.output.VCProverResult;
import edu.clemson.rsrg.nProver.registry.CongruenceClassRegistry;
import edu.clemson.rsrg.nProver.utilities.theorems.ElaborationRule;
import edu.clemson.rsrg.nProver.utilities.theorems.ElaborationRules;
import edu.clemson.rsrg.nProver.utilities.theorems.TheoremStore;
import edu.clemson.rsrg.nProver.utilities.treewakers.AbstractRegisterSequent;
import edu.clemson.rsrg.nProver.utilities.treewakers.RegisterAntecedent;
import edu.clemson.rsrg.nProver.utilities.treewakers.RegisterSuccedent;
import edu.clemson.rsrg.parsing.data.LocationDetailModel;
import edu.clemson.rsrg.statushandling.Fault;
import edu.clemson.rsrg.statushandling.FaultType;
import edu.clemson.rsrg.treewalk.TreeWalker;
import edu.clemson.rsrg.typeandpopulate.entry.TheoremEntry;
import edu.clemson.rsrg.typeandpopulate.symboltables.ModuleScope;
import edu.clemson.rsrg.typeandpopulate.typereasoning.TypeGraph;
import edu.clemson.rsrg.vcgeneration.VCGenerator;
import edu.clemson.rsrg.vcgeneration.sequents.Sequent;
import edu.clemson.rsrg.vcgeneration.utilities.VerificationCondition;

import java.util.*;
import java.util.concurrent.TimeUnit;

import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.STGroup;
import org.stringtemplate.v4.STGroupFile;
import static edu.clemson.rsrg.vcgeneration.VCGenerator.FLAG_VERIFY_VC;

/**
 * <p>
 * This class is a general purpose prover that attempts to prove the {@code VCs} generated by {@link VCGenerator}.
 * </p>
 *
 * @author Yu-Shan Sun
 * @author Nicodemus Msafiri J. M.
 *
 * @version 1.0
 */
public class GeneralPurposeProver {

    // ===========================================================
    // Member Fields
    // ===========================================================

    /**
     * <p>
     * The current job's compilation environment that stores all necessary objects and flags.
     * </p>
     */
    private final CompileEnvironment myCompileEnvironment;

    /**
     * <p>
     * The module scope for the file we are generating automated proofs for.
     * </p>
     */
    private final ModuleScope myCurrentModuleScope;

    /**
     * <p>
     * The number of tries before halting the automated prover
     * </p>
     */
    private final int myNumTriesBeforeHalting;

    /**
     * <p>
     * The various different output listeners that are expecting an update.
     * </p>
     */
    private List<OutputListener> myOutputListeners;

    /**
     * <p>
     * The number of milliseconds before stopping the prove for a VC.
     * </p>
     */
    private final long myTimeout;

    /**
     * <p>
     * The total number of milliseconds spent proving VCs in this file.
     * </p>
     */
    private long myTotalElapsedTime;

    /**
     * <p>
     * This is the math type graph that indicates relationship between different math types.
     * </p>
     */
    private final TypeGraph myTypeGraph;

    /**
     * <p>
     * The module's final list of verification conditions.
     * </p>
     */
    private final List<VerificationCondition> myVerificationConditions;

    // -----------------------------------------------------------
    // Output-Related
    // -----------------------------------------------------------

    /**
     * <p>
     * String template groups for storing all the prover details.
     * </p>
     */
    private final STGroup mySTGroup;

    /**
     * <p>
     * String template for the prover generation details model.
     * </p>
     */
    private final ST myProofGenDetailsModel;

    /**
     * <p>
     * A list containing the prover results for each VC.
     * </p>
     */
    private final List<VCProverResult> myVCProverResults;

    // ===========================================================
    // Flag Strings
    // ===========================================================

    public static final String FLAG_SECTION_NAME = "Prover";
    private static final String FLAG_DESC_GP_PROVER = "General Purpose Automated Prover"; // DESC -- Description
    private static final String FLAG_DESC_PROVER_NUMTRIES = "Number of Failed VCs Before Halting the Prover.";
    private static final String[] NUMTRIES_ARGS = { "numtries" };
    private static final String FLAG_DESC_PROVER_TIMEOUT = "Number of Milliseconds to Use as a Timeout Before Skipping Proving a VC.";
    private static final String[] FLAG_TIMEOUT_ARGS = { "milliseconds" };

    // ===========================================================
    // Flags
    // ===========================================================

    /**
     * Tells the compiler to prove the sequent VCs
     */
    public static final Flag FLAG_PROVE = new Flag(FLAG_SECTION_NAME, "sprove", FLAG_DESC_GP_PROVER); // sequent
    // prove

    /**
     * <p>
     * Specifies number of milliseconds before skipping proving a VC.
     * </p>
     */
    private static final Flag FLAG_TIMEOUT = new Flag(FLAG_SECTION_NAME, "timeout", FLAG_DESC_PROVER_TIMEOUT,
            FLAG_TIMEOUT_ARGS, Flag.Type.HIDDEN);

    /**
     * <p>
     * Specify number of failed VCs before halting the prover.
     * </p>
     */
    private static final Flag FLAG_NUMTRIES = new Flag(FLAG_SECTION_NAME, "num_tries", FLAG_DESC_PROVER_NUMTRIES,
            NUMTRIES_ARGS, Flag.Type.HIDDEN);

    /**
     * <p>
     * Add all the required and implied flags for the {@code GeneralPurposeProver}.
     * </p>
     */
    public static void setUpFlags() {
        FlagDependencies.addImplies(FLAG_PROVE, FLAG_VERIFY_VC); // adding prove flag, also add verify VC flag
        FlagDependencies.addRequires(FLAG_TIMEOUT, FLAG_PROVE);
        FlagDependencies.addRequires(FLAG_NUMTRIES, FLAG_PROVE);
    }

    // ===========================================================
    // Constructors
    // ===========================================================

    /**
     * <p>
     * This creates an instance of the general purpose automated prover.
     * </p>
     *
     * @param vcs
     *            The list of VCs to be proven.
     * @param moduleScope
     *            The module scope associated with {@code name}.
     * @param compileEnvironment
     *            The current job's compilation environment that stores all necessary objects and flags.
     */
    public GeneralPurposeProver(List<VerificationCondition> vcs, ModuleScope moduleScope,
            CompileEnvironment compileEnvironment) {
        myCompileEnvironment = compileEnvironment;
        myCurrentModuleScope = moduleScope;
        myOutputListeners = myCompileEnvironment.getOutputListeners();
        mySTGroup = new STGroupFile("templates/nProverVerboseOutput.stg");
        myTotalElapsedTime = 0;
        myTypeGraph = compileEnvironment.getTypeGraph();
        myVCProverResults = new ArrayList<>(vcs.size());
        myVerificationConditions = vcs;
        myProofGenDetailsModel = mySTGroup.getInstanceOf("outputProofGenDetails");

        // Timeout
        if (myCompileEnvironment.flags.isFlagSet(FLAG_TIMEOUT)) {
            myTimeout = Long.parseLong(myCompileEnvironment.flags.getFlagArgument(FLAG_TIMEOUT, "milliseconds"));
        } else {
            myTimeout = 5000;
        }

        // Number of Tries
        if (myCompileEnvironment.flags.isFlagSet(FLAG_NUMTRIES)) {
            myNumTriesBeforeHalting = Integer
                    .parseInt(myCompileEnvironment.flags.getFlagArgument(FLAG_NUMTRIES, "numtries"));
        } else {
            myNumTriesBeforeHalting = -1;
        }

        // Store verbose output about this module
        ST header;
        ModuleDec moduleDec = myCurrentModuleScope.getDefiningElement();
        if (moduleDec instanceof ConceptModuleDec) {
            header = mySTGroup.getInstanceOf("outputConceptHeader").add("conceptName", moduleDec.getName().getName());
        } else if (moduleDec instanceof ConceptRealizModuleDec) {
            header = mySTGroup.getInstanceOf("outputConceptRealizHeader")
                    .add("realizName", moduleDec.getName().getName())
                    .add("conceptName", ((ConceptRealizModuleDec) moduleDec).getConceptName().getName());
        } else if (moduleDec instanceof EnhancementModuleDec) {
            header = mySTGroup.getInstanceOf("outputEnhancementHeader")
                    .add("enhancementName", moduleDec.getName().getName())
                    .add("conceptName", ((EnhancementModuleDec) moduleDec).getConceptName().getName());
        } else if (moduleDec instanceof EnhancementRealizModuleDec) {
            header = mySTGroup.getInstanceOf("outputEnhancementRealizHeader")
                    .add("realizName", moduleDec.getName().getName())
                    .add("enhancementName", ((EnhancementRealizModuleDec) moduleDec).getEnhancementName().getName())
                    .add("conceptName", ((EnhancementRealizModuleDec) moduleDec).getConceptName().getName());
        } else {
            header = mySTGroup.getInstanceOf("outputFacilityHeader").add("facilityName", moduleDec.getName().getName());
        }
        myProofGenDetailsModel.add("fileHeader", header.render());
    }

    // ===========================================================
    // Public Methods
    // ===========================================================

    /**
     * <p>
     * This method returns the prover setting for how many unproved {@code VCs} we allow before halting.
     * </p>
     *
     * @return The number of tries with -1 indicating that we attempt to prove all VCs.
     */
    public final int getNumTriesBeforeHalting() {
        return myNumTriesBeforeHalting;
    }

    /**
     * <p>
     * This method returns the prover setting for the maximum amount of time we can spend proving each {@code VC}.
     * </p>
     *
     * @return The time that can be spent proving each {@code VC} in ms.
     */
    public final long getTimeout() {
        return myTimeout;
    }

    /**
     * <p>
     * This method returns the total elapsed time that we spent proving {@code VCs} in this {@link ModuleDec}.
     * </p>
     *
     * @return The total elapsed time in ms.
     */
    public final long getTotalElapsedTime() {
        return myTotalElapsedTime;
    }

    /**
     * <p>
     * This method returns a list containing the proof details for each {@code VC}.
     * </p>
     *
     * @return A {@link List} of {@link VCProverResult}.
     */
    public final List<VCProverResult> getVCProverResults() {
        return myVCProverResults;
    }

    /**
     * <p>
     * This method returns the verbose mode output with how we attempted to prove each {@code VCs} in this
     * {@link ModuleDec}.
     * </p>
     *
     * @return A string containing lots of details.
     */
    public final String getVerboseModeOutput() {
        return myProofGenDetailsModel.render();
    }

    /**
     * <p>
     * This method runs the general purpose prover on all the VCs.
     * </p>
     */
    public void proveVCs() {
        // Keep track to total elapsed time and number of unproved/timed out VCs
        myTotalElapsedTime = System.currentTimeMillis();
        int numUnproved = 0;

        // Use the new TheoremStore to preload theorems for fast lookup.
        TheoremStore theoremStore = new TheoremStore(myCurrentModuleScope);
        // Map<String, Integer> expLabels = theoremStore.getExpLabels();

        Map<String, Integer> expLabels = new LinkedHashMap<>();
        // revert ExpLabels to before Senior Project Team things
        // NM: 0, 1 are spared for <= (1), = (2), etc., the list can expand with more reflexive operators
        // preload <=, = into the map
        expLabels.put("<=", AbstractRegisterSequent.OP_LESS_THAN_OR_EQUALS);
        expLabels.put("=", AbstractRegisterSequent.OP_EQUALS);

        // Loop through each of the VCs and attempt to prove them
        for (int i = 0; i < myVerificationConditions.size(); i++) {
            // TODO: Create new threads for each VC, and kill them if they run for too long
            // if (i == 3) {

            List<String> mappings = new ArrayList<>(theoremStore.getLabelList());
            VerificationCondition vc = myVerificationConditions.get(i);

            System.out.println(
                    "====================================== VC #" + i + " =====================================");
            System.out.println(vc);
            // Store the start time for generating proofs for this VC
            long startTime = System.nanoTime();
            // Obtain the sequent to be proved
            Sequent sequent = vc.getSequent();

            // Create a registry and label map
            CongruenceClassRegistry registry = new CongruenceClassRegistry(1000, 1000, 1000, 1000);
            Set<TheoremEntry> relevantTheorems = theoremStore.getRelevantTheorems(sequent.getAntecedents(),
                    sequent.getConcequents());

            // Visit antecedents
            RegisterAntecedent regAntecedent = new RegisterAntecedent(registry, expLabels, 3, mappings);
            for (Exp exp : sequent.getAntecedents()) {
                TreeWalker.visit(regAntecedent, exp);
            }

            // Visit consequents
            RegisterSuccedent regConsequent = new RegisterSuccedent(regAntecedent.getRegistry(),
                    regAntecedent.getExpLabels(), regAntecedent.getNextLabel(), mappings);
            for (Exp exp : sequent.getConcequents()) {
                TreeWalker.visit(regConsequent, exp);
            }

            // Store the end time for generating proofs for this VC
            long endTime = System.nanoTime();

            // Store the prover results for this VC
            myVCProverResults.add(
                    new VCProverResult(vc, TimeUnit.MILLISECONDS.convert(endTime - startTime, TimeUnit.NANOSECONDS),
                            registry.checkIfProved(), false, false));

            // Store the verbose proof detail for this VC
            String result = registry.checkIfProved() ? "Proved" : "Not Proved";
            storeVCProofVerboseDetail(vc, result, registry, expLabels);

            System.out.println("Status: " + result + "\n");

            // System.out.println("============ CongruenceClassRegistry ===============");
            // System.out.println(registry.toString());

            ElaborationRules rules = new ElaborationRules(relevantTheorems);

            System.out.println(
                    "=========================== Relevant Theorems (VC #" + i + ") ===========================");
            int j = 0;
            for (TheoremEntry te : relevantTheorems) {
                System.out.println("Theorem " + i + "_" + j + ": " + "\u001B[33m" + te.getName() + "\u001B[0m"
                        + " (from " + "\u001B[34m" + te.getSourceModuleIdentifier() + "\u001B[0m" + ")");
                System.out.println(te.getAssertion());
                System.out.println();
                j++;
            }

            System.out.println("============ Elaboration Rules (VC #" + i + ") ===============");
            System.out.println(rules);

            System.out.println("============ VC #" + i + " (Printed again for reference) " + " ===============");
            System.out.println(vc);

            System.out.println("============ Elaboration & Matching (VC #" + i + ") ===============");

            List<String> expLabelsToStringList = expLabelsToList(expLabels);
            elaborate(registry, rules.getMyElaborationRules(), expLabels);

            System.out.println("=== Congruence Classes ===");
            for (int k = 1; registry.isClassDesignator(k); k++) {
                registry.displayCongruence(expLabelsToStringList, k);
            }
            // }
        }

        // Compute the total elapsed time in generating proofs for the VCs in this
        // module
        myTotalElapsedTime = System.currentTimeMillis() - myTotalElapsedTime;

    }

    // ===========================================================
    // Private Methods
    // ===========================================================

    /**
     * <p>
     * An helper method that stores verbose detail about proving this {@code VC}.
     * </p>
     *
     * @param vc
     *            The {@link VerificationCondition} we have attempted to prove.
     * @param result
     *            The prover results.
     * @param registry
     *            The congruence class registry used on this {@code VC}.
     * @param expLabels
     *            The expression labels assigned to the expressions in this {@code VC}.
     */
    private void storeVCProofVerboseDetail(VerificationCondition vc, String result, CongruenceClassRegistry registry,
            Map<String, Integer> expLabels) {
        // Create a model for adding all the details associated with this VC.
        LocationDetailModel detailModel = vc.getLocationDetailModel();
        ST vcModel = mySTGroup.getInstanceOf("outputVC");
        vcModel.add("vcNum", vc.getName());

        // Add additional detail if this VC has impacting reduction
        if (vc.getHasImpactingReductionFlag()) {
            vcModel.add("hasImpactingReduction", true);
        }

        // Warn the user if are missing the LocationDetailModel
        if (detailModel != null) {
            vcModel.add("location", detailModel.getDestinationLoc());
            vcModel.add("locationDetail", detailModel.getDetailMessage());
        } else {
            Fault vcGenMissingInfo = new Fault(FaultType.MISSING_INFO_VC_GEN, vc.getLocation(),
                    "[FileOutputListener] VC " + vc.getName() + " is missing information about "
                            + "how this VC got generated.",
                    false);
            myCompileEnvironment.getStatusHandler().registerAndStreamFault(vcGenMissingInfo);
        }

        // Output the associated sequent
        Sequent sequent = vc.getSequent();
        ST sequentModel = mySTGroup.getInstanceOf("outputSequent");
        sequentModel.add("consequents", sequent.getConcequents());
        sequentModel.add("antecedents", sequent.getAntecedents());

        // Add this sequent to our vc model
        vcModel.add("sequent", sequentModel.render());

        // Store the congruence class registry array information
        ST ccRegistryArraysModel = mySTGroup.getInstanceOf("outputCCRegistryArrays");
        ccRegistryArraysModel.add("clusterArguments", registry.getClusterArgArray());
        ccRegistryArraysModel.add("clusters", registry.getClusterArray());
        ccRegistryArraysModel.add("plantations", registry.getStandArray()); // plantations are now stands
        ccRegistryArraysModel.add("classes", registry.getCongruenceClassArray());

        // Add the VC to the VC proof detail model
        ST vcProofDetailModel = mySTGroup.getInstanceOf("outputVCProofDetails");
        vcProofDetailModel.add("vcNum", vc.getName());
        vcProofDetailModel.add("vc", vcModel.render());
        vcProofDetailModel.add("result", result);
        vcProofDetailModel.add("expLabels", expLabels);
        vcProofDetailModel.add("registryArrays", ccRegistryArraysModel.render());

        // Add VC proof detail model to prover generation details
        myProofGenDetailsModel.add("vcProofDetails", vcProofDetailModel.render());
    }

    /**
     * <p>
     * Elaborates on congruence classes using the provided elaboration rules.
     * </p>
     */
    private void elaborate(CongruenceClassRegistry registry, List<ElaborationRule> rules,
            Map<String, Integer> expLabels) {

        int elaborationRuleCounter = 0;

        for (ElaborationRule elaborationRule : rules) {
            elaborationRuleCounter++;
            for (Exp precursor : elaborationRule.getPrecursorClauses()) {
                if (!(precursor instanceof AbstractFunctionExp))
                    continue;

                int operator = expLabels.get(precursor.getTopLevelOperator());

                int currentCCAccessor = registry.firstCCAccessorForTreeNodeLabel(operator);

                boolean foundMatch = false;
                do { // Loop through the congruence classes
                    if (!isUltimateAntecedent(registry, currentCCAccessor)) {
                        foundMatch = ccMatchesExpression(registry, precursor, expLabels, currentCCAccessor, operator);
                        if (foundMatch) {
                            break;
                        }
                    }
                    currentCCAccessor = registry.advanceCClassAccessor(operator, currentCCAccessor);
                    // This is called c in Bill's email
                } while (!registry.isVarietyMaximal(operator, currentCCAccessor));
                if (foundMatch) {
                    System.out.println("[Rule #" + elaborationRuleCounter + "] \u001B[42m Matched! \u001B[49m :"
                            + precursor.toString());
                } else {
                    System.out.println("[Rule #" + elaborationRuleCounter + "] \u001B[41m Not Matched \u001B[49m :"
                            + precursor.toString());
                }
            }
        }
    }

    private boolean ccMatchesExpression(CongruenceClassRegistry registry, Exp needToMatch,
            Map<String, Integer> expLabels, int currentCCAccessor, int operator) { // Determines if anything in the
                                                                                   // Congruence Class matches the Exp

        // A cluster's argument is a single CC, so no need to loop through those or use a variety at this point
        int currentClusterAccessor = registry.getFirstClusterAccessorForCC(currentCCAccessor, operator); // This is p

        do { // Loop through the clusters in the stand
             // If we've made it this far, then we have at least one cluster with the correct root node

            List<Integer> clusterArgs = registry
                    .getArgumentsList(registry.getCongruenceCluster(currentClusterAccessor));
            List<Exp> subExpressions = needToMatch.getSubExpressions();

            if (clusterArgs.size() != subExpressions.size())
                continue; // If the # of args don't match, then this is not the cluster we're looking for

            boolean matchedAllArgs = true;
            for (Exp subExp : subExpressions) { // We need to recursively check the arguments of this cluster
                if (!(subExp instanceof AbstractFunctionExp)) { // Base Case: At a leaf node
                    // TODO: Make this work for theories other than String theory
                    String expString = subExp.toString();
                    if (subExp.toString().equals("Empty_String")) { // Constants require exact match
                        if (registry.getCongruenceCluster(currentClusterAccessor).getTreeNodeLabel()
                                .equals(expLabels.get(expString))) {
                            continue;
                        } else {
                            matchedAllArgs = false;
                            break;
                        }
                    } else { // All variables are an automatic match
                        continue;
                    }

                }

                boolean matchedThisSubExp = false;
                int subExpOperator = expLabels.get(subExp.getTopLevelOperator());

                for (int arg : clusterArgs) {
                    int clusterArgumentOperator = registry.getCongruenceCluster(arg).getTreeNodeLabel();

                    if (subExpOperator != clusterArgumentOperator)
                        continue; // If the args don't match, no point in checking deeper.

                    matchedThisSubExp = ccMatchesExpression(registry, subExp, expLabels, arg, subExpOperator);
                    if (matchedThisSubExp)
                        break; // We found a match! No need to check the rest of the clusters
                }

                matchedAllArgs = matchedThisSubExp;
                if (!matchedThisSubExp) { // None of this cluster's arguments matched subExp. Therefore this is not the
                                          // cluster we're looking for.
                    break;
                }
            }

            if (matchedAllArgs) { // All of the arguments in this cluster matched all of the arguments in our
                                  // expression!
                return true;
            }

            currentClusterAccessor = registry.advanceClusterAccessor(operator, currentClusterAccessor);
            // This doesn't look like the dissertation & might be wrong.
        } while (!registry.isStandMaximal(operator, currentClusterAccessor));

        // If we've reached this point, we looped through the entire stand without matching a cluster.
        return false;
    }

    private static void displayArgumentLists(ElaborationRule elaborationRule, Exp precursor, int elaborationRuleCounter,
            List<String> arglist, int currentCCAccessor, int currentClusterAccessor, List<Integer> argListCCNums) {

        System.out.println("Elaboration Rule #" + elaborationRuleCounter);
        System.out.println("Precursor: " + precursor);
        System.out.println("Source Theorem: " + "\u001B[33m" + elaborationRule.getSourceTheoremName() + "\u001B[0m"
                + " (from: " + "\u001B[34m" + elaborationRule.getSourceModuleName() + "\u001B[0m" + ")");
        System.out.println("Argument List for operator " + "\u001B[33m" + precursor.getTopLevelOperator() + "\u001B[0m"
                + ": " + "\u001B[35m" + arglist + "\u001B[0m");
        System.out.println("Argument CC Accessors: " + "\u001B[35m" + argListCCNums + "\u001B[0m");
        System.out.println("currentClassAccessor: " + "\u001B[35m" + currentCCAccessor + "\u001B[0m");
        System.out.println("currentClusterAccessor: " + "\u001B[34m" + currentClusterAccessor + "\u001B[0m" + "\n");
    }

    private boolean isUltimateAntecedent(CongruenceClassRegistry registry, int ccAccessor) {
        BitSet attr = registry.getCongruenceClass(ccAccessor).getAttribute();
        return attr.get(2) && attr.get(0);
    }

    private List<String> expLabelsToList(Map<String, Integer> expLabels) {
        int maxIndex = expLabels.values().stream().max(Integer::compare).orElse(0);

        List<String> list = new ArrayList<>(Collections.nCopies(maxIndex + 1, null));

        for (Map.Entry<String, Integer> entry : expLabels.entrySet()) {
            list.set(entry.getValue(), entry.getKey());
        }

        for (int i = 0; i < list.size(); i++) {
            if (list.get(i) == null)
                list.add("null");
        }

        return list;
    }
}
