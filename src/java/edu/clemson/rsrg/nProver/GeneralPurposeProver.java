/*
 * GeneralPurposeProver.java
 * ---------------------------------
 * Copyright (c) 2024
 * RESOLVE Software Research Group
 * School of Computing
 * Clemson University
 * All rights reserved.
 * ---------------------------------
 * This file is subject to the terms and conditions defined in
 * file 'LICENSE.txt', which is part of this source code package.
 */
package edu.clemson.rsrg.nProver;

import edu.clemson.rsrg.absyn.declarations.moduledecl.*;
import edu.clemson.rsrg.absyn.expressions.Exp;
import edu.clemson.rsrg.absyn.expressions.mathexpr.FunctionExp;
import edu.clemson.rsrg.absyn.expressions.mathexpr.InfixExp;
import edu.clemson.rsrg.init.CompileEnvironment;
import edu.clemson.rsrg.init.flag.Flag;
import edu.clemson.rsrg.init.flag.FlagDependencies;
import edu.clemson.rsrg.init.output.OutputListener;
import edu.clemson.rsrg.nProver.output.VCProverResult;
import edu.clemson.rsrg.nProver.registry.CongruenceClassRegistry;
import edu.clemson.rsrg.nProver.utilities.theorems.ElaborationRule;
import edu.clemson.rsrg.nProver.utilities.theorems.ElaborationRules;
import edu.clemson.rsrg.nProver.utilities.theorems.TheoremStore;
import edu.clemson.rsrg.nProver.utilities.treewakers.AbstractRegisterSequent;
import edu.clemson.rsrg.nProver.utilities.treewakers.RegisterAntecedent;
import edu.clemson.rsrg.nProver.utilities.treewakers.RegisterSuccedent;
import edu.clemson.rsrg.parsing.data.LocationDetailModel;
import edu.clemson.rsrg.statushandling.Fault;
import edu.clemson.rsrg.statushandling.FaultType;
import edu.clemson.rsrg.treewalk.TreeWalker;
import edu.clemson.rsrg.typeandpopulate.entry.TheoremEntry;
import edu.clemson.rsrg.typeandpopulate.symboltables.ModuleScope;
import edu.clemson.rsrg.typeandpopulate.typereasoning.TypeGraph;
import edu.clemson.rsrg.vcgeneration.VCGenerator;
import edu.clemson.rsrg.vcgeneration.sequents.Sequent;
import edu.clemson.rsrg.vcgeneration.utilities.VerificationCondition;

import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.STGroup;
import org.stringtemplate.v4.STGroupFile;
import static edu.clemson.rsrg.vcgeneration.VCGenerator.FLAG_VERIFY_VC;

/**
 * <p>
 * This class is a general purpose prover that attempts to prove the {@code VCs} generated by {@link VCGenerator}.
 * </p>
 *
 * @author Yu-Shan Sun
 * @author Nicodemus Msafiri J. M.
 *
 * @version 1.0
 */
public class GeneralPurposeProver {

    // ===========================================================
    // Member Fields
    // ===========================================================

    /**
     * <p>
     * The current job's compilation environment that stores all necessary objects and flags.
     * </p>
     */
    private final CompileEnvironment myCompileEnvironment;

    /**
     * <p>
     * The module scope for the file we are generating automated proofs for.
     * </p>
     */
    private final ModuleScope myCurrentModuleScope;

    /**
     * <p>
     * The number of tries before halting the automated prover
     * </p>
     */
    private final int myNumTriesBeforeHalting;

    /**
     * <p>
     * The various different output listeners that are expecting an update.
     * </p>
     */
    private List<OutputListener> myOutputListeners;

    /**
     * <p>
     * The number of milliseconds before stopping the prove for a VC.
     * </p>
     */
    private final long myTimeout;

    /**
     * <p>
     * The total number of milliseconds spent proving VCs in this file.
     * </p>
     */
    private long myTotalElapsedTime;

    /**
     * <p>
     * This is the math type graph that indicates relationship between different math types.
     * </p>
     */
    private final TypeGraph myTypeGraph;

    /**
     * <p>
     * The module's final list of verification conditions.
     * </p>
     */
    private final List<VerificationCondition> myVerificationConditions;

    // -----------------------------------------------------------
    // Output-Related
    // -----------------------------------------------------------

    /**
     * <p>
     * String template groups for storing all the prover details.
     * </p>
     */
    private final STGroup mySTGroup;

    /**
     * <p>
     * String template for the prover generation details model.
     * </p>
     */
    private final ST myProofGenDetailsModel;

    /**
     * <p>
     * A list containing the prover results for each VC.
     * </p>
     */
    private final List<VCProverResult> myVCProverResults;

    // ===========================================================
    // Flag Strings
    // ===========================================================

    public static final String FLAG_SECTION_NAME = "Prover";
    private static final String FLAG_DESC_GP_PROVER = "General Purpose Automated Prover"; // DESC -- Description
    private static final String FLAG_DESC_PROVER_NUMTRIES = "Number of Failed VCs Before Halting the Prover.";
    private static final String[] NUMTRIES_ARGS = { "numtries" };
    private static final String FLAG_DESC_PROVER_TIMEOUT = "Number of Milliseconds to Use as a Timeout Before Skipping Proving a VC.";
    private static final String[] FLAG_TIMEOUT_ARGS = { "milliseconds" };

    // ===========================================================
    // Flags
    // ===========================================================

    /**
     * Tells the compiler to prove the sequent VCs
     */
    public static final Flag FLAG_PROVE = new Flag(FLAG_SECTION_NAME, "sprove", FLAG_DESC_GP_PROVER); // sequent
    // prove

    /**
     * <p>
     * Specifies number of milliseconds before skipping proving a VC.
     * </p>
     */
    private static final Flag FLAG_TIMEOUT = new Flag(FLAG_SECTION_NAME, "timeout", FLAG_DESC_PROVER_TIMEOUT,
            FLAG_TIMEOUT_ARGS, Flag.Type.HIDDEN);

    /**
     * <p>
     * Specify number of failed VCs before halting the prover.
     * </p>
     */
    private static final Flag FLAG_NUMTRIES = new Flag(FLAG_SECTION_NAME, "num_tries", FLAG_DESC_PROVER_NUMTRIES,
            NUMTRIES_ARGS, Flag.Type.HIDDEN);

    /**
     * <p>
     * Add all the required and implied flags for the {@code GeneralPurposeProver}.
     * </p>
     */
    public static void setUpFlags() {
        FlagDependencies.addImplies(FLAG_PROVE, FLAG_VERIFY_VC); // adding prove flag, also add verify VC flag
        FlagDependencies.addRequires(FLAG_TIMEOUT, FLAG_PROVE);
        FlagDependencies.addRequires(FLAG_NUMTRIES, FLAG_PROVE);
    }

    // ===========================================================
    // Constructors
    // ===========================================================

    /**
     * <p>
     * This creates an instance of the general purpose automated prover.
     * </p>
     *
     * @param vcs
     *            The list of VCs to be proven.
     * @param moduleScope
     *            The module scope associated with {@code name}.
     * @param compileEnvironment
     *            The current job's compilation environment that stores all necessary objects and flags.
     */
    public GeneralPurposeProver(List<VerificationCondition> vcs, ModuleScope moduleScope,
            CompileEnvironment compileEnvironment) {
        myCompileEnvironment = compileEnvironment;
        myCurrentModuleScope = moduleScope;
        myOutputListeners = myCompileEnvironment.getOutputListeners();
        mySTGroup = new STGroupFile("templates/nProverVerboseOutput.stg");
        myTotalElapsedTime = 0;
        myTypeGraph = compileEnvironment.getTypeGraph();
        myVCProverResults = new ArrayList<>(vcs.size());
        myVerificationConditions = vcs;
        myProofGenDetailsModel = mySTGroup.getInstanceOf("outputProofGenDetails");

        // Timeout
        if (myCompileEnvironment.flags.isFlagSet(FLAG_TIMEOUT)) {
            myTimeout = Long.parseLong(myCompileEnvironment.flags.getFlagArgument(FLAG_TIMEOUT, "milliseconds"));
        } else {
            myTimeout = 5000;
        }

        // Number of Tries
        if (myCompileEnvironment.flags.isFlagSet(FLAG_NUMTRIES)) {
            myNumTriesBeforeHalting = Integer
                    .parseInt(myCompileEnvironment.flags.getFlagArgument(FLAG_NUMTRIES, "numtries"));
        } else {
            myNumTriesBeforeHalting = -1;
        }

        // Store verbose output about this module
        ST header;
        ModuleDec moduleDec = myCurrentModuleScope.getDefiningElement();
        if (moduleDec instanceof ConceptModuleDec) {
            header = mySTGroup.getInstanceOf("outputConceptHeader").add("conceptName", moduleDec.getName().getName());
        } else if (moduleDec instanceof ConceptRealizModuleDec) {
            header = mySTGroup.getInstanceOf("outputConceptRealizHeader")
                    .add("realizName", moduleDec.getName().getName())
                    .add("conceptName", ((ConceptRealizModuleDec) moduleDec).getConceptName().getName());
        } else if (moduleDec instanceof EnhancementModuleDec) {
            header = mySTGroup.getInstanceOf("outputEnhancementHeader")
                    .add("enhancementName", moduleDec.getName().getName())
                    .add("conceptName", ((EnhancementModuleDec) moduleDec).getConceptName().getName());
        } else if (moduleDec instanceof EnhancementRealizModuleDec) {
            header = mySTGroup.getInstanceOf("outputEnhancementRealizHeader")
                    .add("realizName", moduleDec.getName().getName())
                    .add("enhancementName", ((EnhancementRealizModuleDec) moduleDec).getEnhancementName().getName())
                    .add("conceptName", ((EnhancementRealizModuleDec) moduleDec).getConceptName().getName());
        } else {
            header = mySTGroup.getInstanceOf("outputFacilityHeader").add("facilityName", moduleDec.getName().getName());
        }
        myProofGenDetailsModel.add("fileHeader", header.render());
    }

    // ===========================================================
    // Public Methods
    // ===========================================================

    /**
     * <p>
     * This method returns the prover setting for how many unproved {@code VCs} we allow before halting.
     * </p>
     *
     * @return The number of tries with -1 indicating that we attempt to prove all VCs.
     */
    public final int getNumTriesBeforeHalting() {
        return myNumTriesBeforeHalting;
    }

    /**
     * <p>
     * This method returns the prover setting for the maximum amount of time we can spend proving each {@code VC}.
     * </p>
     *
     * @return The time that can be spent proving each {@code VC} in ms.
     */
    public final long getTimeout() {
        return myTimeout;
    }

    /**
     * <p>
     * This method returns the total elapsed time that we spent proving {@code VCs} in this {@link ModuleDec}.
     * </p>
     *
     * @return The total elapsed time in ms.
     */
    public final long getTotalElapsedTime() {
        return myTotalElapsedTime;
    }

    /**
     * <p>
     * This method returns a list containing the proof details for each {@code VC}.
     * </p>
     *
     * @return A {@link List} of {@link VCProverResult}.
     */
    public final List<VCProverResult> getVCProverResults() {
        return myVCProverResults;
    }

    /**
     * <p>
     * This method returns the verbose mode output with how we attempted to prove each {@code VCs} in this
     * {@link ModuleDec}.
     * </p>
     *
     * @return A string containing lots of details.
     */
    public final String getVerboseModeOutput() {
        return myProofGenDetailsModel.render();
    }

    /**
     * <p>
     * This method runs the general purpose prover on all the VCs.
     * </p>
     */
    public void proveVCs() {
        // Keep track to total elapsed time and number of unproved/timed out VCs
        myTotalElapsedTime = System.currentTimeMillis();
        int numUnproved = 0;

        // Use the new TheoremStore to preload theorems for fast lookup.
        TheoremStore theoremStore = new TheoremStore(myCurrentModuleScope);
        // Map<String, Integer> expLabels = theoremStore.getExpLabels();

        Map<String, Integer> expLabels = new LinkedHashMap<>();
        // revert ExpLabels to before Senior Project Team things
        // NM: 0, 1 are spared for <= (1), = (2), etc., the list can expand with more reflexive operators
        // preload <=, = into the map
        expLabels.put("<=", AbstractRegisterSequent.OP_LESS_THAN_OR_EQUALS);
        expLabels.put("=", AbstractRegisterSequent.OP_EQUALS);

        // Loop through each of the VCs and attempt to prove them
        for (int i = 0; i < myVerificationConditions.size(); i++) {
            if (i == 3) {

                List<String> mappings = new ArrayList<>(theoremStore.getLabelList());
                VerificationCondition vc = myVerificationConditions.get(i);

                System.out.println(
                        "====================================== VC #" + i + " =====================================");
                System.out.println(vc);
                // Store the start time for generating proofs for this VC
                long startTime = System.nanoTime();
                // Obtain the sequent to be proved
                Sequent sequent = vc.getSequent();

                // Create a registry and label map
                CongruenceClassRegistry registry = new CongruenceClassRegistry(1000, 1000, 1000, 1000);
                Set<TheoremEntry> relevantTheorems = theoremStore.getRelevantTheorems(sequent.getAntecedents(),
                        sequent.getConcequents());

                // Visit antecedents
                RegisterAntecedent regAntecedent = new RegisterAntecedent(registry, expLabels, 3, mappings);
                for (Exp exp : sequent.getAntecedents()) {
                    TreeWalker.visit(regAntecedent, exp);
                }

                // Visit consequents
                RegisterSuccedent regConsequent = new RegisterSuccedent(regAntecedent.getRegistry(),
                        regAntecedent.getExpLabels(), regAntecedent.getNextLabel(), mappings);
                for (Exp exp : sequent.getConcequents()) {
                    TreeWalker.visit(regConsequent, exp);
                }

                // Store the end time for generating proofs for this VC
                long endTime = System.nanoTime();

                // Store the prover results for this VC
                myVCProverResults.add(
                        new VCProverResult(vc, TimeUnit.MILLISECONDS.convert(endTime - startTime, TimeUnit.NANOSECONDS),
                                registry.checkIfProved(), false, false));

                // Store the verbose proof detail for this VC
                String result = registry.checkIfProved() ? "Proved" : "Not Proved";
                storeVCProofVerboseDetail(vc, result, registry, expLabels);

                System.out.println("Status: " + result + "\n");

                // System.out.println("============ CongruenceClassRegistry ===============");
                // System.out.println(registry.toString());

                ElaborationRules rules = new ElaborationRules(relevantTheorems);

                System.out.println(
                        "=========================== Relevant Theorems (VC #" + i + ") ===========================");
                int j = 0;
                for (TheoremEntry te : relevantTheorems) {
                    System.out.println("Theorem " + i + "_" + j + ": " + "\u001B[33m" + te.getName() + "\u001B[0m"
                            + " (from " + "\u001B[34m" + te.getSourceModuleIdentifier() + "\u001B[0m" + ")");
                    System.out.println(te.getAssertion());
                    System.out.println();
                    j++;
                }

                System.out.println("============ Elaboration Rules (VC #" + i + ") ===============");
                System.out.println(rules);

                System.out.println("============ Elaboration & Matching (VC #" + i + ") ===============");

                List<String> expLabelsToStringList = expLabelsToList(expLabels);
                elaborate(registry, rules.getMyElaborationRules(), expLabelsToStringList, expLabels);

                System.out.println("=== Congruence Classes ===");
                System.out.println("Antecedent/Ultimate: " + "\u001B[35m" + "{0, 2}" + "\u001B[0m");
                System.out.println("Succedent/Ultimate: " + "\u001B[35m" + "{1, 2}" + "\u001B[0m");
                System.out.println("Non-Ultimate: " + "\u001B[35m" + "{}" + "\u001B[0m");
                System.out.println();
                for (int k = 1; registry.isClassDesignator(k); k++) {
                    registry.displayCongruence(expLabelsToStringList, k);
                }
            }
        }

        // Compute the total elapsed time in generating proofs for the VCs in this
        // module
        myTotalElapsedTime = System.currentTimeMillis() - myTotalElapsedTime;

    }

    // ===========================================================
    // Private Methods
    // ===========================================================

    /**
     * <p>
     * An helper method that stores verbose detail about proving this {@code VC}.
     * </p>
     *
     * @param vc
     *            The {@link VerificationCondition} we have attempted to prove.
     * @param result
     *            The prover results.
     * @param registry
     *            The congruence class registry used on this {@code VC}.
     * @param expLabels
     *            The expression labels assigned to the expressions in this {@code VC}.
     */
    private void storeVCProofVerboseDetail(VerificationCondition vc, String result, CongruenceClassRegistry registry,
            Map<String, Integer> expLabels) {
        // Create a model for adding all the details associated with this VC.
        LocationDetailModel detailModel = vc.getLocationDetailModel();
        ST vcModel = mySTGroup.getInstanceOf("outputVC");
        vcModel.add("vcNum", vc.getName());

        // Add additional detail if this VC has impacting reduction
        if (vc.getHasImpactingReductionFlag()) {
            vcModel.add("hasImpactingReduction", true);
        }

        // Warn the user if are missing the LocationDetailModel
        if (detailModel != null) {
            vcModel.add("location", detailModel.getDestinationLoc());
            vcModel.add("locationDetail", detailModel.getDetailMessage());
        } else {
            Fault vcGenMissingInfo = new Fault(FaultType.MISSING_INFO_VC_GEN, vc.getLocation(),
                    "[FileOutputListener] VC " + vc.getName() + " is missing information about "
                            + "how this VC got generated.",
                    false);
            myCompileEnvironment.getStatusHandler().registerAndStreamFault(vcGenMissingInfo);
        }

        // Output the associated sequent
        Sequent sequent = vc.getSequent();
        ST sequentModel = mySTGroup.getInstanceOf("outputSequent");
        sequentModel.add("consequents", sequent.getConcequents());
        sequentModel.add("antecedents", sequent.getAntecedents());

        // Add this sequent to our vc model
        vcModel.add("sequent", sequentModel.render());

        // Store the congruence class registry array information
        ST ccRegistryArraysModel = mySTGroup.getInstanceOf("outputCCRegistryArrays");
        ccRegistryArraysModel.add("clusterArguments", registry.getClusterArgArray());
        ccRegistryArraysModel.add("clusters", registry.getClusterArray());
        ccRegistryArraysModel.add("plantations", registry.getStandArray()); // plantations are now stands
        ccRegistryArraysModel.add("classes", registry.getCongruenceClassArray());

        // Add the VC to the VC proof detail model
        ST vcProofDetailModel = mySTGroup.getInstanceOf("outputVCProofDetails");
        vcProofDetailModel.add("vcNum", vc.getName());
        vcProofDetailModel.add("vc", vcModel.render());
        vcProofDetailModel.add("result", result);
        vcProofDetailModel.add("expLabels", expLabels);
        vcProofDetailModel.add("registryArrays", ccRegistryArraysModel.render());

        // Add VC proof detail model to prover generation details
        myProofGenDetailsModel.add("vcProofDetails", vcProofDetailModel.render());
    }

    /**
     * <p>
     * Elaborates on congruence classes using the provided elaboration rules.
     * </p>
     */
    private void elaborate(CongruenceClassRegistry registry, List<ElaborationRule> rules, List<String> mappings,
            Map<String, Integer> expLabels) {

        int elaborationRuleCounter = 0;

        for (ElaborationRule elaborationRule : rules) {
            elaborationRuleCounter++;
            for (Exp precursor : elaborationRule.getPrecursorClauses()) {
                if (!(precursor instanceof FunctionExp || precursor instanceof InfixExp))
                    continue;

                int operator = expLabels.get(precursor.getTopLevelOperator());

                int currentCCAccessor = 0;
                currentCCAccessor = registry.firstCCAccessorForTreeNodeLabel(operator);

                do {
                    if (!isUltimateAntecedent(registry, currentCCAccessor)) {
                        // this checks if we're getting an antecedent
                        int currentClusterAccessor = 0; // this is p
                        // The recursion starts here, according to Chris
                        currentClusterAccessor = registry.getFirstClusterAccessorForCC(currentCCAccessor, operator);
                        do {
                            List<String> arglist = new ArrayList<>();
                            List<Integer> argListCCNums = registry.getArgumentsList(
                                    registry.getCongruenceCluster(currentClusterAccessor));
                            if (!argListCCNums.isEmpty()) {
                                arglist = registry.reverseLabelMapping(argListCCNums, mappings);
                                displayArgumentLists(elaborationRule, precursor, elaborationRuleCounter, arglist,
                                        currentCCAccessor, currentClusterAccessor, argListCCNums);

                            }
                            boolean isMatched = false;
                            if (arglist.size() == precursor.getSubExpressions().size()) {
                                for (String arg : arglist) {
                                    // TODO Make sure we don't match the same element twice
                                    for (Exp subExp : precursor.getSubExpressions()) {
                                        if (arg.equals(subExp.getTopLevelOperator())) {
                                            // TODO Move deeper into the trees. This will probably be a recursive call,
                                            // & it will probably involve moving most of this method into a helper
                                            // method
                                            System.out.println("Argument: " + arg + " - SubExp Operator: "
                                                    + subExp.getTopLevelOperator() + "\n");
                                        }
                                        // TODO If this is not an operator, we need to put this in the resultant of the
                                        // Elaboration Rule
                                    }
                                }
                            }
                            currentClusterAccessor = registry.advanceClusterAccessor(operator, currentClusterAccessor);
                            // This doesn't look like the dissertation & might be wrong.
                        } while (!registry.isStandMaximal(operator, currentClusterAccessor));
                    }
                    currentCCAccessor = registry.advanceCClassAccessor(operator, currentCCAccessor);
                    // This is called c in Bill's email
                } while (!registry.isVarietyMaximal(operator, currentCCAccessor));
            }
        }
    }

    private static void displayArgumentLists(ElaborationRule elaborationRule, Exp precursor, int elaborationRuleCounter,
            List<String> arglist, int currentCCAccessor, int currentClusterAccessor, List<Integer> argListCCNums) {

        System.out.println("Elaboration Rule #" + elaborationRuleCounter);
        System.out.println("Precursor: " + precursor);
        System.out.println("Source Theorem: " + "\u001B[33m" + elaborationRule.getSourceTheoremName() + "\u001B[0m"
                + " (from: " + "\u001B[34m" + elaborationRule.getSourceModuleName() + "\u001B[0m" + ")");
        System.out.println("Argument List for operator " + "\u001B[33m" + precursor.getTopLevelOperator() + "\u001B[0m"
                + ": " + "\u001B[35m" + arglist + "\u001B[0m");
        System.out.println("Argument CC Accessors: " + "\u001B[35m" + argListCCNums + "\u001B[0m");
        System.out.println("currentClassAccessor: " + "\u001B[35m" + currentCCAccessor + "\u001B[0m");
        System.out.println("currentClusterAccessor: " + "\u001B[34m" + currentClusterAccessor + "\u001B[0m" + "\n");
    }

    private boolean isUltimateAntecedent(CongruenceClassRegistry registry, int ccAccessor) {
        BitSet attr = registry.getCongruenceClass(ccAccessor).getAttribute();
        return attr.get(2) && attr.get(0);
    }

    private List<String> expLabelsToList(Map<String, Integer> expLabels) {
        int maxIndex = expLabels.values().stream().max(Integer::compare).orElse(0);

        List<String> list = new ArrayList<>(Collections.nCopies(maxIndex + 1, null));

        for (Map.Entry<String, Integer> entry : expLabels.entrySet()) {
            list.set(entry.getValue(), entry.getKey());
        }

        for (int i = 0; i < list.size(); i++) {
            if (list.get(i) == null)
                list.add("null");
        }

        return list;
    }
}
